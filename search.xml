<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java之基础语法篇</title>
      <link href="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/"/>
      <url>/2022/02/10/java-zhi-ji-chu-yu-fa-pian/</url>
      
        <content type="html"><![CDATA[<h4 id="Java之基础语法篇"><a href="#Java之基础语法篇" class="headerlink" title="Java之基础语法篇"></a>Java之基础语法篇</h4><h5 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h5><ul><li><p>单行注释</p><p><code>格式：    // 注释信息</code></p></li><li><p>多行注释</p><p><code>格式：    /* 注释信息 */</code> </p></li><li><p>文档注释</p><p><code>格式：    /** 注释信息*/</code></p></li></ul><h5 id="2、关键字（50个）"><a href="#2、关键字（50个）" class="headerlink" title="2、关键字（50个）"></a>2、关键字（50个）</h5><ul><li>关键字的字母全部小写</li><li>有特殊的颜色标记</li></ul><h5 id="3、常量"><a href="#3、常量" class="headerlink" title="3、常量"></a>3、常量</h5><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210201515314.png"></p><p><strong>注意：</strong>空常量不能直接输出</p><h5 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h5><p>计算机存储设备的最小信息单元叫 <strong>位（bit）</strong> ，又称<strong>比特位</strong>，常用小写字母 <strong>b</strong> 表示；而计算机中最小的存储单位为 <strong>字节（byte）</strong>，通常用大写字母 <strong>B</strong> 表示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> B（byte） <span class="token operator">=</span> <span class="token number">8</span> b<span class="token number">1</span> KB <span class="token operator">=</span> <span class="token number">1024</span> B<span class="token number">1</span> MB <span class="token operator">=</span> <span class="token number">1024</span> KB<span class="token number">1</span> GB <span class="token operator">=</span> <span class="token number">1024</span> MB<span class="token number">1</span> TB <span class="token operator">=</span> <span class="token number">1024</span> GB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210202546063.png"></p><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210202633533.png"></p><h5 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a>5、变量</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*变量定义格式：数据类型 变量名 = 变量值;基本数据类型：byte,short,int,long,float,double,char,boolean变量的使用：取值格式：变量名修改值格式：变量名 = 变量值;*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li>变量名不能重复</li><li>变量未赋值时不能使用</li><li><code>long</code>类型变量定义时，为防止整数过大，在后面加<code>L</code>，如 <code>long a = 100000L</code></li><li><code>float</code>类型变量定义时，为防止类型不兼容，在后面加<code>F</code>，如 <code>float b = 3.14F</code></li></ul><h5 id="6、标识符"><a href="#6、标识符" class="headerlink" title="6、标识符"></a>6、标识符</h5><h6 id="①-定义规则："><a href="#①-定义规则：" class="headerlink" title="① 定义规则："></a><strong>① 定义规则：</strong></h6><ul><li>由<strong>数字、字母、下划线（_）和美元符（$）</strong>组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>区分大小写</li></ul><h6 id="②-常见命名约定"><a href="#②-常见命名约定" class="headerlink" title="② 常见命名约定"></a><strong>② 常见命名约定</strong></h6><p><strong>小驼峰命名法：（方法、变量）</strong></p><ul><li>标识符是一个单词时，首字母小写，如 <code>name</code></li><li>标识符由多个单词组成时，第一个单词首字母小写，其他单词首字母大写，如 <code>firstName</code></li></ul><p><strong>大驼峰命名法：（类）</strong></p><ul><li>标识符是一个单词时，首字母大写，如 <code>Student</code></li><li>标识符由多个单词组成时，每个单词首字母大写，如 <code>GoodStudent</code></li></ul><h5 id="7、类型转换"><a href="#7、类型转换" class="headerlink" title="7、类型转换"></a>7、类型转换</h5><h6 id="①-自动类型转换"><a href="#①-自动类型转换" class="headerlink" title="① 自动类型转换"></a>① 自动类型转换</h6><p>把一个表示<strong>数据范围小的数值或变量</strong>赋值给另一个表示<strong>数据范围大的变量</strong></p><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210205542768.png"></p><h6 id="②-强制类型转换"><a href="#②-强制类型转换" class="headerlink" title="② 强制类型转换"></a>② 强制类型转换</h6><p>把一个表示<strong>数据范围大的数值或变量</strong>赋值给另一个表示<strong>数据范围小的变量</strong></p><ul><li>格式：<strong>目标数据类型 变量名 = (目标数据类型)值或者变量</strong>，如 <code>int k = (int)88.88</code></li></ul><h5 id="8、算数运算符"><a href="#8、算数运算符" class="headerlink" title="8、算数运算符"></a>8、算数运算符</h5><p><code>+,-,*,/,%</code></p><p><strong>整数操作只得整数，想得小数，浮点数参与</strong></p><h6 id="①-字符的”-”操作"><a href="#①-字符的”-”操作" class="headerlink" title="① 字符的”+”操作"></a>① 字符的”+”操作</h6><p>字符参与加操作，使用字符在计算机底层<strong>对应的数值</strong>来进行计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*ASCII码表中，A~Z为65~90，a~z为97~122，'0'~'9'为48~57*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>算术表达式中<strong>包含多个基本数据类型</strong>的值的时候，整个算术表达式的<strong>类型</strong>会<strong>自动进行提升</strong></p><p><strong>提升规则：</strong></p><ul><li><code>byte</code>类型，<code>short</code>类型和<code>char</code>类型将被提升到int类型</li><li>整个表达式的类型自动提升到表达式中最高等级操作数同样的类型，等级顺序如自动类型转换中的图</li></ul><h6 id="②-字符串的”-”操作"><a href="#②-字符串的”-”操作" class="headerlink" title="② 字符串的”+”操作"></a>② 字符串的”+”操作</h6><ul><li><p>当”+”操作中出现字符串时，这个”+”是<strong>字符串连接符</strong>，而不是算术运算</p><p>如<code>&quot;hello&quot; + 666</code>编译结果为 <code>hello666</code></p></li><li><p>在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行”+”操作时，从左到右逐个执行，如</p><p><code>1 + 99 + &quot;年&quot;</code>编译结果为 <code>100年</code></p><p><code>&quot;年&quot; + 1 + 99</code> 编译结果为<code>年199</code></p></li></ul><h5 id="9、赋值运算符"><a href="#9、赋值运算符" class="headerlink" title="9、赋值运算符"></a>9、赋值运算符</h5><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210213143725.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*扩展的赋值运算符底层隐含了强制类型转换short s = 10;// 可以正确编译，常用s += 20;// 不能正确编译，10为 int 类型，右侧运算完后，为 int 类型，而左侧依然为 short 类型s = s + 10// 正确写法，右侧运算完后强制类型转换s = (short)(s + 10)*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="10、自增自减运算符"><a href="#10、自增自减运算符" class="headerlink" title="10、自增自减运算符"></a>10、自增自减运算符</h5><p><code>++,--</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*i++ VS ++i①单独使用，二者效果相同②参与操作使用，i++ 先赋值后加一，++i 先加一后赋值（i--和--i类似）*/</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">10</span><span class="token comment">// 编译后，j = 10, i = 11</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 编译后，k = 11, i = 11</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token operator">++</span>l<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="11、关系运算符"><a href="#11、关系运算符" class="headerlink" title="11、关系运算符"></a>11、关系运算符</h5><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210214308154.png"></p><h5 id="12、逻辑运算符"><a href="#12、逻辑运算符" class="headerlink" title="12、逻辑运算符"></a>12、逻辑运算符</h5><p>逻辑运算符是用来<strong>连接关系表达式</strong>的运算符，也可以直接<strong>连接布尔类型的常量或变量</strong></p><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210215300616.png"></p><p><strong>短路逻辑运算符</strong></p><p><img src="/2022/02/10/java-zhi-ji-chu-yu-fa-pian/image-20220210215656296.png"></p><h5 id="13、三元运算符"><a href="#13、三元运算符" class="headerlink" title="13、三元运算符"></a>13、三元运算符</h5><ul><li>格式： 关系表达式 ? 表达式1 : 表达式2</li><li>范例： <code>a &gt; b ? a : b</code></li></ul><p><strong>计算规则：</strong></p><ul><li>首先<strong>计算关系表达式的值</strong></li><li>若值为<code>true</code>，<strong>表达式1的值</strong>就是运算结果</li><li>若值为<code>flase</code>，<strong>表达式2的值</strong>就是运算结果</li></ul><h5 id="14、数据输入"><a href="#14、数据输入" class="headerlink" title="14、数据输入"></a>14、数据输入</h5><p><strong>Scanner使用的基本步骤：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ①导包，导包动作必须出现在类定义的上面</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token punctuation">;</span><span class="token comment">// ②创建对象，只有sc是变量名可变，其他不许变</span><span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ③接收数据，只有i可以变</span><span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ④关闭扫描器，在使用完scanner输入操作后，将其关闭，避免一直占用资源</span>sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在基础步骤上，对于输入的数据加以判断</strong></p><ul><li><p>通过 <code>Scanner</code> 类的 <code>next()</code> 与 <code>nextLine()</code> 方法获取输入的字符串，在读取前一般需要 使用 <code>hasNext()</code> 与 <code>hasNextLine()</code> 判断是否还有输入的数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建对象</span><span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断是否还有输入</span><span class="token keyword">if</span> <span class="token punctuation">(</span>scan<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 输入数据</span>    <span class="token class-name">String</span> str2 <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入的数据为："</span> <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 关闭</span>scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>要输入 <code>int</code> 或 <code>float</code> 等类型的数据，在 <code>Scanner</code> 类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx()</code> 方法进行验证，再使用 <code>nextXxx()</code> 来读取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建对象</span><span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断输入的是否是整数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>scan<span class="token punctuation">.</span><span class="token function">hasNextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接收整数</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"整数数据："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 输入错误的信息</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入的不是整数！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 关闭</span>scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>在Scanner类中next() 与 nextLine() 区别</strong></p><p><strong>next():</strong></p><ul><li>一定要读取到有效字符后才可以结束输入</li><li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符</li><li>next() 不能得到带有空格的字符串</li></ul><p><strong>nextLine()：</strong></p><ul><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白</li></ul><h5 id="15、流程控制"><a href="#15、流程控制" class="headerlink" title="15、流程控制"></a>15、流程控制</h5><p><strong>分类：</strong></p><ul><li>顺序结构（代码依次执行）</li><li>分支结构（<strong>if，switch</strong>）</li><li>循环结构（<strong>for，while，do…while</strong>）</li></ul><h5 id="16、if语句"><a href="#16、if语句" class="headerlink" title="16、if语句"></a>16、if语句</h5><h6 id="①-格式一："><a href="#①-格式一：" class="headerlink" title="① 格式一："></a>① 格式一：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 如果布尔表达式为true将执行的语句</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="②-格式二："><a href="#②-格式二：" class="headerlink" title="② 格式二："></a>② 格式二：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 如果布尔表达式的值为true</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 如果布尔表达式的值为false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="③格式三："><a href="#③格式三：" class="headerlink" title="③格式三："></a>③格式三：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//如果布尔表达式 1的值为true执行代码</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式 <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//如果布尔表达式 2的值为true执行代码</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式 <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//如果布尔表达式 3的值为true执行代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//如果以上布尔表达式都不为true执行代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="17、switch语句"><a href="#17、switch语句" class="headerlink" title="17、switch语句"></a>17、switch语句</h5><p><code>switch case</code> 语句语法格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> value <span class="token operator">:</span>                <span class="token comment">//语句      </span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//可选    </span>    <span class="token keyword">case</span> value <span class="token operator">:</span>               <span class="token comment">//语句       </span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//可选    </span>    <span class="token comment">//你可以有任意数量的case语句    </span>    <span class="token keyword">default</span> <span class="token operator">:</span> <span class="token comment">//可选       </span>        <span class="token comment">//语句 </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>switch case</code> 语句有如下规则：</p><ul><li><code>switch</code> 语句中的变量类型可以是： <code>byte</code>、<code>short</code>、<code>int</code> 或者 <code>char</code>。从 Java SE 7 开始，<code>switch</code> 支持字符串 <code>String</code> 类型了，同时 <code>case</code> 标签必须为字符串常量或字面量</li><li><code>switch</code> 语句可以拥有多个 <code>case</code> 语句。每个 <code>case</code> 后面跟一个要比较的值和冒号</li><li><code>case</code> 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 <code>switch</code> 语句</li><li>当遇到 <code>break</code> 语句时，<code>switch</code> 语句终止。程序跳转到 <code>switch</code> 语句后面的语句执行。<code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句</li><li><code>switch</code> 语句可以包含一个 <code>default</code> 分支，该分支一般是 <code>switch</code> 语句的最后一个分支（可以在任何位置，但<strong>建议在最后一个</strong>）。<code>default</code> 在没有 <code>case</code> 语句的值和变量值相等的时候执行。<code>default</code> 分支不需要 <code>break</code> 语句</li><li><strong>case穿透</strong>：如果<code>case</code> 控制的语句体后面不写<code>break</code>，将会出现穿透现象，在不判断下个<code>case</code> 值的情况下，向下运行，知道遇到<code>break</code> 或者整个switch语句的结束</li></ul><p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p><h5 id="18、for循环语句"><a href="#18、for循环语句" class="headerlink" title="18、for循环语句"></a>18、for循环语句</h5><p>for<strong>循环执行的次数是在执行前就确定的</strong>。语法格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>初始化<span class="token punctuation">;</span> 布尔表达式<span class="token punctuation">;</span> 更新<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//代码语句</span><span class="token punctuation">&#125;</span><span class="token comment">/*初始化：初始化语句 -> 表示循环开启的起始状态布尔表达式：条件判断语句 -> 表示循环反复执行的条件更新：条件控制语句 -> 表示循环执行中每次变化的内容代码语句的内容为循环体语句 -> 表示循环重复执行的内容*/</span><span class="token comment">// 死循环格式</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 for 循环有以下几点说明：</p><ul><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句</li><li>然后，检测布尔表达式的值。如果为 <code>true</code>，循环体被执行。如果为<code>false</code>，循环终止，开始执行循环体后面的语句</li><li>执行一次循环后，更新循环控制变量</li><li>再次检测布尔表达式。循环执行上面的过程</li></ul><p><strong>增强for循环</strong></p><p>Java5 引入了一种主要<strong>用于数组的增强型 for 循环</strong>。</p><p>Java 增强 <code>for</code> 循环语法格式如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>声明语句 <span class="token operator">:</span> 表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//代码句子</span><span class="token punctuation">&#125;</span><span class="token comment">// 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</span><span class="token comment">// 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</span><span class="token comment">// 例子</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token string">"Larry"</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> <span class="token string">"Lacy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token class-name">String</span> name <span class="token operator">:</span> names <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> name <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 执行结果为 James,Larry,Tom,Lacy,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="19、while循环语句"><a href="#19、while循环语句" class="headerlink" title="19、while循环语句"></a>19、while循环语句</h5><p><strong>while是最基本的循环</strong>，它的结构为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span> 布尔表达式 <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//循环内容</span><span class="token punctuation">&#125;</span><span class="token comment">// 只要布尔表达式为 true，循环就会一直执行下去</span><span class="token comment">// 标准化格式</span>初始化语句<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>条件判断语句<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    循环体语句<span class="token punctuation">;</span>    条件控制语句<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 死循环格式</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="20、do…while循环语句"><a href="#20、do…while循环语句" class="headerlink" title="20、do…while循环语句"></a>20、do…while循环语句</h5><p><code>do…while</code> 循环和 <code>while</code> 循环相似，不同的是，<code>do…while</code> 循环<strong>至少会执行一次</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">初始化语句<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    循环体语句<span class="token punctuation">;</span>    条件控制语句<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 死循环格式</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>布尔表达式（条件判断语句）在循环体的后面，所以<strong>语句块在检测布尔表达式之前已经执行了</strong>。 如果布尔表达式的值为 <code>true</code>，则语句块一直执行，直到布尔表达式的值为 <code>false</code> </p><h5 id="21、跳转控制语句"><a href="#21、跳转控制语句" class="headerlink" title="21、跳转控制语句"></a>21、跳转控制语句</h5><p><strong>两个关键字都是基于条件控制的</strong></p><p><strong>① continue：</strong></p><p><code>continue</code> 适用于任何循环控制结构中。作用是<strong>让程序立刻跳转到下一次循环的迭代执行</strong>。</p><ul><li>在 <code>for</code> 循环中，<code>continue</code> 语句使程序立即<strong>跳转到更新语句（条件控制语句）</strong></li><li>在 <code>while</code> 或者 <code>do…while</code> 循环中，程序立即<strong>跳转到布尔表达式的条件判断语句</strong></li></ul><p><strong>② break：</strong></p><ul><li><code>break</code> 主要用在循环语句或者 <code>switch</code> 语句中，用来<strong>跳出整个语句块</strong></li><li><code>break</code> 跳出最里层的循环，并且继续执行该循环下面的语句</li></ul><h5 id="22、循环嵌套"><a href="#22、循环嵌套" class="headerlink" title="22、循环嵌套"></a>22、循环嵌套</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 分支语句中包含分支语句称为分支嵌套</span><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 循环语句中包含循环语句称为循环嵌套</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="23、Random"><a href="#23、Random" class="headerlink" title="23、Random"></a>23、Random</h5><p><strong>作用：</strong>用于产生一个随机数</p><p><strong>使用步骤：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ①导包</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span>    <span class="token comment">// ②创建对象</span><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ③获取随机数</span><span class="token keyword">int</span> number <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取数据的范围：[0,10)，包括0，但不包括10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Java.util.Random()</code><strong>方法摘要</strong>：</p><ul><li><code>protected int next(int bits)</code>：生成下一个伪随机数</li><li><code>boolean nextBoolean()</code>：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的<code>boolean</code>值</li><li><code>void nextBytes(byte[] bytes)</code>：生成随机字节并将其置于用户提供的 byte 数组中</li><li><code>double nextDouble()</code>：返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 <code>double</code> 值</li><li><code>float nextFloat()</code>：返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布<code>float</code> 值</li><li><code>double nextGaussian()</code>：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的<code>double</code> 值，其平均值是 0.0，标准差是 1.0</li><li><code>int nextInt()</code>：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 <code>int</code> 值</li><li><code>int nextInt(int n)</code>：返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不包括）之间均匀分布的<code>int</code> 值</li><li><code>long nextLong()</code>：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 <code>long</code> 值</li><li><code>void setSeed(long seed)</code>：使用单个 long 种子设置此随机数生成器的种子</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先队列用法</title>
      <link href="/2022/02/09/you-xian-dui-lie-yong-fa/"/>
      <url>/2022/02/09/you-xian-dui-lie-yong-fa/</url>
      
        <content type="html"><![CDATA[<p>在leetcode刷题过程中，接触到优先队列(priority_queue)的使用，因此作为学习加以补充</p><h3 id="一、总体介绍"><a href="#一、总体介绍" class="headerlink" title="一、总体介绍"></a>一、总体介绍</h3><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器</strong></p><p>Java中_PriorityQueue_实现了_Queue_接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为_PriorityQueue_的底层实现。</p><p><img src="/2022/02/09/you-xian-dui-lie-yong-fa/1.png"></p><h3 id="二、方法剖析"><a href="#二、方法剖析" class="headerlink" title="二、方法剖析"></a>二、方法剖析</h3><h4 id="2-1-add-和offer"><a href="#2-1-add-和offer" class="headerlink" title="2.1 add()和offer()"></a>2.1 add()和offer()</h4><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于_PriorityQueue_这两个方法其实没什么差别。<br><img src="/2022/02/09/you-xian-dui-lie-yong-fa/2.png"><br>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//offer(E e)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//不允许放入null元素</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动扩容</span>    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//队列原来为空，这是插入的第一个元素</span>        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//siftUp()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//parentNo = (nodeNo-1)/2</span>        <span class="token class-name">Object</span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//调用比较器的比较方法</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h4 id="2-2-element-和peek"><a href="#2-2-element-和peek" class="headerlink" title="2.2 element()和peek()"></a>2.2 element()和peek()</h4><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。<br><img src="/2022/02/09/you-xian-dui-lie-yong-fa/3.png"><br>代码也就非常简洁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//peek()</span><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//0下标处的那个元素就是最小的那个</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-remove-和poll"><a href="#2-3-remove-和poll" class="headerlink" title="2.3 remove()和poll()"></a>2.3 remove()和poll()</h4><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。<br><img src="/2022/02/09/you-xian-dui-lie-yong-fa/4.png"><br>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">--</span>size<span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//0下标处的那个元素就是最小的那个</span>    <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//siftDown()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//leftNo = parentNo*2+1</span>        <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>            comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//然后用c取代原来的值</span>        k <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-remove-Object-o"><a href="#2-4-remove-Object-o" class="headerlink" title="2.4 remove(Object o)"></a>2.4 remove(Object o)</h4><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是_Queue_接口内的方法，而是_Collection_接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。<br><img src="/2022/02/09/you-xian-dui-lie-yong-fa/5.png"><br>具体代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//remove(Object o)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">--</span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token comment">//情况1</span>        queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> moved <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> moved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//情况2</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题之单链表篇</title>
      <link href="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/"/>
      <url>/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* 代码初始结构 * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一、六大解题套路"><a href="#一、六大解题套路" class="headerlink" title="一、六大解题套路"></a>一、六大解题套路</h4><h5 id="1-1-合并两个有序链表（双指针技巧）"><a href="#1-1-合并两个有序链表（双指针技巧）" class="headerlink" title="1.1 合并两个有序链表（双指针技巧）"></a>1.1 合并两个有序链表（双指针技巧）</h5><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/title.jpg"></p><p><strong>代码1：</strong></p><p>思路：使用<strong>双指针技巧</strong>和<strong>虚拟头结点技巧</strong>，算法的逻辑类似于「拉拉链」，<code>l1, l2</code> 类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并。 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 虚拟头结点</span>    <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token comment">// 双指针技巧，在此算法中双指针也可不用</span>    <span class="token class-name">ListNode</span> p1 <span class="token operator">=</span> l1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 比较 p1 和 p2 两个指针</span>        <span class="token comment">// 将值较小的的节点接到 p 指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val <span class="token operator">></span> p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// p 指针不断前进</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码2：递归</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 很新颖的递归使用</span><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> res <span class="token operator">=</span> list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val <span class="token operator">?</span> list1 <span class="token operator">:</span> list2<span class="token punctuation">;</span>        res<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>next<span class="token punctuation">,</span>list1<span class="token punctuation">.</span>val <span class="token operator">>=</span> list2<span class="token punctuation">.</span>val <span class="token operator">?</span> list1 <span class="token operator">:</span> list2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-合并k个升序链表"><a href="#1-2-合并k个升序链表" class="headerlink" title="1.2 合并k个升序链表"></a><strong>1.2 合并k个升序链表</strong></h5><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/title2.jpg"></p><p><strong>代码1：</strong></p><p>思路：使用优先级队列（二叉堆）把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点，即用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空。<strong>算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 虚拟头结点</span>    <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ListNode</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token comment">// 优先级队列，最小堆</span><span class="token comment">/*        // JAVA之前，使用匿名内部类。记得初始化队列长度    PriorityQueue&lt;ListNode> pq=new PriorityQueue&lt;>(lists.length,new Comparator&lt;ListNode>()&#123;        @Override        public int compare(ListNode l1,ListNode l2)&#123;        // 在添加元素的时候就进行规则排序。升序            if(l1.bal>l2.val)&#123;                return 1;            &#125;else if(l1.val==l2.val)&#123;                return 0;            &#125;else&#123;                return -1;            &#125;        &#125;    &#125;);*/</span>           <span class="token comment">// Java8后使用lambda表达式更加高效、简捷</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ListNode</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>        lists<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>val <span class="token operator">-</span> b<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 k 个链表的头结点加入最小堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ListNode</span> head <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 进行非空判断，防止里面存在空的子数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 插入的时候已经进行了排序,最小的元素放在最前面</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取最小节点，接到结果链表中</span>        <span class="token class-name">ListNode</span> node <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// p 指针不断前进</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-单链表的倒数第k个节点"><a href="#1-3-单链表的倒数第k个节点" class="headerlink" title="1.3 单链表的倒数第k个节点"></a>1.3 单链表的倒数第k个节点</h5><p>假设链表有 <code>n</code> 个节点，找单链表的第 <code>k</code> 个节点，一个 for 循环遍历就找到了；若要找倒数第 <code>k</code> 个节点，反过来就是正数第 <code>n - k</code> 个节点；一般算法只给一个 <code>ListNode</code> 头结点代表一条单链表，需要先遍历一遍链表算出 <code>n</code> 的值，然后再遍历链表计算第 <code>n - k</code> 个节点。也就是说，这个解法需要<strong>遍历两次链表</strong>才能得到出倒数第 <code>k</code> 个节点。</p><p>能不能<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点？可以，巧妙使用双指针技巧</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 返回链表的倒数第 k 个节点</span><span class="token class-name">ListNode</span> <span class="token function">findFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ListNode</span> p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">// 让第一个指针 p1 先走 k 步</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">ListNode</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">// p1 和 p2 同时走 n - k 步</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// p2 现在指向第 n - k 个节点</span>    <span class="token keyword">return</span> p2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽说遍历一次链表和遍历两次链表的时间复杂度都是 <code>O(N)</code>，但上述这个算法更有技巧性。</p><p><strong>技巧的leetcode题</strong></p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/title3.jpg"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 虚拟头结点</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// next链接链表</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span>        <span class="token class-name">ListNode</span> x <span class="token operator">=</span> <span class="token function">findFromEnd</span><span class="token punctuation">(</span>dummy<span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 删掉倒数第 n 个节点</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">findFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210115622925.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 快慢指针初始化指向 head</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 快指针走到末尾时停止</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 慢指针走一步，快指针走两步</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 慢指针指向中点</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果链表长度为<strong>偶数</strong>，也就是说中点有两个的时候，我们这个解法返回的节点是<strong>靠后的那个节点</strong>。</p><p>另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p><h5 id="1-4-判断链表是否包含环"><a href="#1-4-判断链表是否包含环" class="headerlink" title="1.4 判断链表是否包含环"></a>1.4 判断链表是否包含环</h5><p>判断链表是否包含环属于经典问题了，解决方案也是<strong>用快慢指针</strong></p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210120318689.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 慢指针走一步，快指针走两步</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 快慢指针相遇，说明含有环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 不包含环</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果链表中含有环，<strong>如何计算这个环的起点</strong>？</p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210120404094.png"></p><p><strong>思路：</strong>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ListNode</span> fast<span class="token punctuation">,</span> slow<span class="token punctuation">;</span>    fast <span class="token operator">=</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 上面的代码类似 hasCycle 函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// fast 遇到空指针说明没有环</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 重新指向头结点</span>    slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">// 快慢指针同步前进，相交点就是环起点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> slow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原理：</strong>假设快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210120937196.png"></p><p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。</p><p>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走k步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了：</p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210120957366.png"></p><p>所以，只要把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点。</p><h5 id="1-5-两个链表是否相交"><a href="#1-5-两个链表是否相交" class="headerlink" title="1.5 两个链表是否相交"></a>1.5 两个链表是否相交</h5><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210121324448.png"></p><p>用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p><p>**解决这个问题的关键是，通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code>**。</p><p>可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p><p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code></p><p><img src="/2022/02/09/leetcode-shua-ti-zhi-dan-lian-biao-pian/image-20220210121244978.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)，两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度*/</span><span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span>    <span class="token class-name">ListNode</span> p1 <span class="token operator">=</span> headA<span class="token punctuation">,</span> p2 <span class="token operator">=</span> headB<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> p1 <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> p2 <span class="token operator">=</span> headA<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> p1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 空间复杂度为 O(1)，时间复杂度为 O(N)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题之框架思维</title>
      <link href="/2022/02/09/leetcode-shua-ti-zhi-kuang-jia-si-wei/"/>
      <url>/2022/02/09/leetcode-shua-ti-zhi-kuang-jia-si-wei/</url>
      
        <content type="html"><![CDATA[<h3 id="所谓框架思维"><a href="#所谓框架思维" class="headerlink" title="所谓框架思维"></a>所谓框架思维</h3><h4 id="一、存储方式"><a href="#一、存储方式" class="headerlink" title="一、存储方式"></a>一、存储方式</h4><p>数据结构的存储方式只有两种：<strong>数组（顺序存储）</strong>、<strong>链表（链式存储）</strong></p><p>散列表、栈、队列、堆、树、图等等各种数据结构都属于「上层建筑」，而数组和链表才是「结构基础」。这些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作。</p><ol><li><p><strong>「队列」</strong>、<strong>「栈」</strong>这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</p></li><li><p><strong>「图」</strong>的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p></li><li><p><strong>「散列表」</strong>就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p></li><li><p><strong>「树」</strong>，用数组实现就是<strong>「堆」</strong>，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</p></li><li><p><strong>二者的优缺点如下</strong>：</p><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</p><p><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以<strong>不能随机访问</strong>；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p></li></ol><h4 id="二、数据结构的基本操作"><a href="#二、数据结构的基本操作" class="headerlink" title="二、数据结构的基本操作"></a>二、数据结构的基本操作</h4><p>数据结构种类很多，但其基本操作无非就是遍历+访问，也就是：<strong>增删查改</strong></p><p>形式分两种：<strong>线性和非线性</strong></p><p><strong>线性就是 for/while 迭代为代表，非线性就是递归为代表。</strong></p><p><strong>数据遍历框架，典型的线性迭代结构</strong>：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void traverse(int[] arr)&#123;for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;&#x2F;&#x2F;迭代访问arr[i]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>链表遍历框架，兼具迭代和递归结构：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 基本的单链表节点 *&#x2F;class ListNode &#123;    int val;    ListNode next;&#125;void traverse(ListNode head) &#123;    for (ListNode p &#x3D; head; p !&#x3D; null; p &#x3D; p.next) &#123;        &#x2F;&#x2F; 迭代访问 p.val    &#125;&#125;void traverse(ListNode head) &#123;    &#x2F;&#x2F; 递归访问 head.val    traverse(head.next);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二叉树遍历框架，典型的非线性递归遍历结构：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 基本的二叉树节点 *&#x2F;class TreeNode &#123;    int val;    TreeNode left, right;&#125;void traverse(TreeNode root) &#123;    &#x2F;&#x2F; 前序遍历代码位置    traverse(root.left);    &#x2F;&#x2F; 中序遍历代码位置    traverse(root.right);    &#x2F;&#x2F; 后序遍历代码位置&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二叉树框架可以扩展为 N 叉树的遍历框架：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 基本的 N 叉树节点 *&#x2F;class TreeNode &#123;    int val;    TreeNode[] children;&#125;void traverse(TreeNode root) &#123;    for (TreeNode child : root.children)        traverse(child);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>N</code>叉树的遍历又可以扩展为图的遍历，因为图就是好几 <code>N</code> 叉棵树的结合体。但图是可能出现环的，用个布尔数组 <code>visited</code> 做标记来解决。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>学会利用框架思维，<strong>涉及到递归问题，学着使用树的遍历框架</strong>，若二叉树框架不行，扩展到N叉树遍历框架，将思路转化为代码，这是个任重道远的问题，<strong>但只要有心，谁都可以学好。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="/2022/02/07/hexo-da-jian-bo-ke/"/>
      <url>/2022/02/07/hexo-da-jian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h4 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h4><h5 id="1-1-下载并安装node-js"><a href="#1-1-下载并安装node-js" class="headerlink" title="1.1 下载并安装node.js"></a>1.1 下载并安装node.js</h5><ul><li>官网下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装后验证：node -v</li></ul><h5 id="1-2-下载并安装git"><a href="#1-2-下载并安装git" class="headerlink" title="1.2 下载并安装git"></a>1.2 下载并安装git</h5><ul><li>官网下载:  <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装后验证：git -v</li></ul><h5 id="1-3-命令行安装cnpm"><a href="#1-3-命令行安装cnpm" class="headerlink" title="1.3  命令行安装cnpm"></a>1.3  命令行安装cnpm</h5><ul><li>命令：<code>npm install -g cnpm --registry==https://registry.npm.taobao.org</code></li><li>安装后验证：cnpm -v</li></ul><h5 id="1-4-命令行安装hexo"><a href="#1-4-命令行安装hexo" class="headerlink" title="1.4 命令行安装hexo"></a>1.4 命令行安装hexo</h5><ul><li>命令：<code>cnpm install -g hexo-cli</code></li><li>安装后验证：hexo  -v</li></ul><h4 id="二、配置github"><a href="#二、配置github" class="headerlink" title="二、配置github"></a>二、配置github</h4><p><strong>创建仓库：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了。每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ul><li>注册的邮箱一定要验证，否则不会成功</li><li>仓库名字必须是：username.github.io，其中username是你的用户名</li></ul><h4 id="三、配置SSH免密登录"><a href="#三、配置SSH免密登录" class="headerlink" title="三、配置SSH免密登录"></a>三、配置SSH免密登录</h4><p>提交代码需要拥有github权限才可以，但是直接使用用户名和密码不安全，所以使用ssh key来解决本地和服务器的连接问题。</p><p><strong>操作步骤：</strong></p><ol><li><p>首先打开电脑文件夹，找到C:\Users\用户名\.ssh文件夹并删除</p></li><li><p>在C:\Users\用户名文件夹下右键打开Git Bash Here输入命令：</p><p>ssh-keygen -t rsa -C github邮件地址  </p><p>生成.ssh秘钥，输入后连敲三次回车</p></li><li><p>生成了一个新的 C:\Users\用户名\.ssh文件夹，打开这个文件夹，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容</p></li><li><p>打开github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可</p></li><li><p>检测是否设置成功：</p><p>输入命令：  <code>$ ssh -T git@github.com</code>        # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><p>Hi xxxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p></li><li><p>此时还需要配置：</p><p>$ git config –global user.name “git用户名”             // 你的github用户名，非昵称</p><p>$ git config –global user.email  “<a href="mailto:&#x78;&#120;&#120;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#120;&#120;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;</a>“      // 填写你的github注册邮箱</p></li></ol><h4 id="四、使用hexo搭建博客"><a href="#四、使用hexo搭建博客" class="headerlink" title="四、使用hexo搭建博客"></a>四、使用hexo搭建博客</h4><h5 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h5><ol><li><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），由于这个文件夹将来就作为存放代码的地方，所以最好不要随便放</p></li><li><p>在该文件夹下右键打开 Git Bash Here，输入hexo init 初始化</p><p>注意：</p><p>​    这里可能会出现Failed to install dependencies的问题，运行 npm install就行；最终会有一行INFO Start blogging with Hexo！如果有那就运行完成</p></li><li><p>执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo g   <span class="token comment">#生成</span>$ hexo s   <span class="token comment">#启动服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>hexo s 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a>  即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见</p><p>解决端口冲突问题请参考这篇文章<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></p><p>到这里就完成了hexo的本地部分，后面进行部署到github上</p></li></ol><h5 id="4-2-将博客部署到github"><a href="#4-2-将博客部署到github" class="headerlink" title="4.2 将博客部署到github"></a>4.2 将博客部署到github</h5><ol><li><p>在上述文件目录下安装 hexo-deployer-git 插件</p><ul><li>安装命令： npm install hexo-deployer-git –save</li><li>必须安装，否则执行hexo d 的话会报错误</li></ul></li><li><p>编辑文件目录下的_config.yml 文件, 在文件末尾添加如下内容：  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: git@github.com:chenkey837/chenkey837.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：其中 repo 中的内容即为 github 个人主页链接地址</p></li><li><p>在文件目录下，输入命令：hexo d 将本地 blog 推送到 github仓库, 前面若<strong>没有进行SSH免密操作</strong>，这里则需要输入 username &amp; pwd</p></li></ol><p>至此博客的初始化基本完成，后续进行主题更换，现域名为<a href="http://chenkey837.github.io/">http://chenkey837.github.io/</a></p><h4 id="五、更换主题"><a href="#五、更换主题" class="headerlink" title="五、更换主题"></a>五、更换主题</h4><h5 id="5-1-寻找主题"><a href="#5-1-寻找主题" class="headerlink" title="5.1 寻找主题"></a>5.1 寻找主题</h5><ul><li><p>hexo官网：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</p></li><li><p>寻找完后，本博客使用github上一个大佬的主题blinkfox/hexo-theme-matery</p></li><li><p>链接：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li></ul><h5 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a>5.2 下载主题</h5><ol><li><p>Git Bash Here中先cd到hexo目录下</p></li><li><p>再输入命令 $ git clone 主题http链接  themes/主题名称，这里若http链接clone失败，按照前文操作下来可以用SSH链接clone，链接为<a href="">git@github.com:blinkfox/hexo-theme-matery.git</a></p><p>注意：theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看</p></li></ol><h5 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a>5.3 使用主题</h5><ul><li>打开hexo目录下的_config.yml文件，在里面找到theme: landscape改为theme: blinkfox  （blinkfox为要使用的主题名）,然后重新执行hexo g来重新生成</li><li>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布</li><li>之后hexo d推送到github仓库</li><li>再次在浏览器中输入对应域名, 即可发现主题已更换，若主题仍无更换，则将将根_config.yml文件中的 branch: master改为main</li><li>音乐id：7264784219</li></ul><h5 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a>5.4 修改主题内容</h5><p>使用的是blinkfox主题，后期相关修改参考大佬发的主题文档</p><p>文档链接：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><ul><li>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的</li><li>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexo根目录右键打开Git Bash Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d  推送到github仓库即可</li><li>这样就可以输入网址查看更改后的内容了</li></ul><p>文档上没有提及的修改：</p><ul><li>返回按钮样式修改：在主题下面的 blinkfox\layout_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p>特别注意：</p><ul><li>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的_config.yml文件</li></ul><h4 id="六、写博客"><a href="#六、写博客" class="headerlink" title="六、写博客"></a>六、写博客</h4><h5 id="6-1-写博客的步骤"><a href="#6-1-写博客的步骤" class="headerlink" title="6.1 写博客的步骤"></a>6.1 写博客的步骤</h5><ol><li><p>创建.md文件，定位到我们的hexo根目录，Git Bash Here 中执行命令：</p><p>  <code>hexo new &#39;my-first-blog&#39;</code>  </p></li><li><p>编写并保存,用typora打开这个文件就可以开始写博客了，写完后Ctrl+S 保存关闭即可</p></li><li><p>清理然后再生成一下，生成后推送到远程仓库即可，hexo根目录下右键Git Bash Here 中依次输入如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>补充：</strong><code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>的区别？</p><ul><li>hexo new page ‘My-second-blog’最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。</li></ul></li></ol><h5 id="6-2-博客插入图片（使用Typora）"><a href="#6-2-博客插入图片（使用Typora）" class="headerlink" title="6.2 博客插入图片（使用Typora）"></a>6.2 博客插入图片（使用Typora）</h5><p>在md文件中插入图片的语法为<code>![]()</code>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p><strong>完美步骤：</strong></p><ol><li><p>安装插件，在hexo根目录打开Git Bash，执行</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改配置_config.yml如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">post_asset_folder: <span class="token boolean">true</span>marked: prependRoot: <span class="token boolean">true</span> postAsset: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置，设置如下</p><p><img src="/2022/02/07/hexo-da-jian-bo-ke/image-20220208205937399.png"></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p></li><li><p>当插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p><p><img src="/2022/02/07/hexo-da-jian-bo-ke/9d8985d94df7b36bfc94c9ce200261f9.png"> </p></li><li><p>最后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/29/hello-world/"/>
      <url>/2022/01/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
